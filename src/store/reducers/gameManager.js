/*
/////////////////\\\\\\\\\\\\\\\\\\\\\
Author: Mohammed Alghamdi
Porpuse: This store file is the root reducer that manages the whole store/state.
/////////////////\\\\\\\\\\\\\\\\\\\\\
*/
import * as actions from '../actions/actions.js';
import CardsDeck from '../objects/CardsDeck.js';
import CoordinatorPlayer from '../objects/CoordinatorPlayer.js';
import Card from '../objects/Card.js';

const intialState = {
    playersData:null, // instance of CoordinatorPlayer
    cardsDeck: null, // instance of CardsDeck
    // 0 means it's turn of the bottom player, 1 is right, 2 is top, and left is 3.
    turnIndex: 0, 
    // It starts how many cards a player can play/waste. Normally it's 1 without playing
    // some action cards like play twice.
    turnCount: [],
    isGameFinished: false, 
    winnerName: "",
    isCardDeckFinished: false
};

// this is a helper function that returns a deep copy of the old state.
function deepCopyState(state){
    let copiedState = {
        playersData: [],
        cardsDeck: state.cardsDeck.clone(),
        turnIndex: state.turnIndex,
        turnCount: [], 
        isGameFinished: state.isGameFinished, 
        winnerName: state.winnerName , 
        isCardDeckFinished: state.isCardDeckFinished
    }
    for (let i = 0; i < state.playersData.length; i++) {
        copiedState.playersData.push(state.playersData[i].clone());
        copiedState.turnCount.push(state.turnCount[i]);
    }
    return copiedState;
}


/**
 * It is a helper function that handles the cards that does not target opponents.
 * @param {Object} state the state parameter passed to dispatch() after deep copying.
 * @param {Object} action is the action paramater passed to dispatch()
 * @return the state after performing the computation. 
 */
function handleNonTargetingCards(state, action) {
    let hasFinished = state.playersData[state.turnIndex].play(action.playedCard, null);
    if (action.playedCard.cardName === Card.PLAY_TWICE) {
        state.turnCount[state.turnIndex] = 2;
    }
    if (hasFinished) {
        state.isGameFinished = true;
        state.winnerName = state.playersData[state.turnIndex].player.playerName;
    }
    return state;
}


/**
 * This is a helper function that returns a new state when hammer card is played
 * @param {Object} state the state parameter passed to dispatch() after deep copying.
 * @param {Object} action is the action paramater passed to dispatch()
 * @param {Boolean} isReflect is true if it's recursive call to indicate that
 *  the attack is not generated by hammer card but by mirror shield.
 * @return the state after performing the computation. 
 */
function handleHammerAttack(state, action, isReflect) {
    if (!isReflect) { // if this is a reflected attack by mirror shield.
        state.playersData[state.turnIndex].play(action.playedCard, null);
    } 
    let hasReflected = state.playersData[action.opponentIndex].react(
        action.attackedField, action.playedCard);
    // because mirror shield has reflected hammer attack, now an opponent is performing
    // a reverse hammer attack.
    if (hasReflected) {
        let newAction = {
            type: actions.PLAY_ACTION,
            playedCard: action.playedCard,
            playerIndex: action.opponentIndex,
            attackedField: action.attackedField,
            opponentIndex: action.playerIndex
        }; 
        state = handleHammerAttack(state, newAction, true);
    }
    return state;
}

/**
 * It is a helper function that handles prevent next turn card.
 * @param {Object} state the state parameter passed to dispatch() after deep copying.
 * @param {Object} action is the action paramater passed to dispatch()
 * @return the state after performing the computation. 
 */
function handlePreventTurn(state, action) {
    state.playersData[state.turnIndex].play(action.playedCard, null);
    state.turnCount[action.opponentIndex] =  state.turnCount[action.opponentIndex] - 1;
    return state;
}

/**
 * It is a helper function that handles sheild destroyer card.
 * @param {Object} state the state parameter passed to dispatch() after deep copying.
 * @param {Object} action is the action paramater passed to dispatch()
 * @return the state after performing the computation. 
 */
function handleShieldDestroyer(state, action) {
    state.playersData[state.turnIndex].play(action.playedCard, action.stolenCard);
    state.playersData[action.opponentIndex].react(
        action.attackedField, action.playedCard);
    return state;
}

/**
 * It is a helper function that handles normal shield stealling, mirror shield stealling
 *  and stone stealling.
 * @param {Object} state the state parameter passed to dispatch() after copying.
 * @param {Object} action is the action paramater passed to dispatch()
 * @return the state after performing the computation. 
 */
function handleSteallingCard(state, action) {
    let hasFinished = state.playersData[state.turnIndex].play(action.playedCard, action.stolenCard);
    state.playersData[action.opponentIndex].react(
        action.attackedField, action.playedCard);
    if (hasFinished) {
        state.isGameFinished = true;
    }
    return state;
}

/**
 * It is a helper function that facilitates pick a card play's computation. It makes this
 * dispatch as if the player played/wasted the picked card from hand.
 * @param {Object} state the state parameter passed to dispatch() after deep copying.
 * @param {Object} action is the action paramater passed to dispatch()
 * @return the state after performing the computation. 
 */
function handleSameCard(state, action) {
    let sameCard = new Card(Card.SAME_CARD, 0);
    state.playersData[state.turnIndex].waste(sameCard);
    state.playersData[state.turnIndex].player.cards.
        push(state.playersData[state.turnIndex].lastPlayedCard);
    return state;
}

/**
 * It is a helper function that facilitates pick a card play's computation. It makes this
 * dispatch as if the player played/wasted the picked card from hand.
 * @param {Object} state the state parameter passed to dispatch() after deep copying.
 * @param {Object} action is the action paramater passed to dispatch()
 * @return the state after performing the computation. 
 */
function handlePickCard(state, action) {
    // replace the "pick a card" with the stolen card.
    let pickCard = new Card(Card.PICK_CARD, 0);
    state.playersData[state.turnIndex].waste(pickCard);
    // remove the picked card from the opponent and adding it to the attacker 's cards
    if (action.playedCard.cardName === Card.PICK_CARD) {
        // player has not picked stone/shield stealing
        state.playersData[action.opponentIndex].waste(action.stolenCard);
        state.playersData[state.turnIndex].player.cards.
        push(new Card(action.stolenCard.cardName, 0));
    } else {
        state.playersData[action.opponentIndex].waste(action.playedCard);
        state.playersData[state.turnIndex].player.cards.
        push(new Card(action.playedCard.cardName, 0));
    }     
    return state;
} 

 /**
  * It handles the edge if wasting picked card.
  * @param {Object} state It's the state instanced that's passed to dispatch() after deep copying.
  * @param {Object} action It's the action object that's passed to dispatch(). 
  */
 function handleWastingPickedCard(state, action) {
    // removing "pick a card" from the player.
    let pickCard = new Card(Card.PICK_CARD, 0);
    state.playersData[state.turnIndex].lastPlayedCard = pickCard;
    state.playersData[state.turnIndex].waste(pickCard);
    state.playersData[state.turnIndex].lastPlayedCard = pickCard;
    // removing the picked card from opponent.
    state.playersData[action.opponentIndex].waste(action.card); 
    return state;
 }

/**
 * It handles the computatuin of playing restore stone card.
 * @param {Object} state It's the state object passed from dispatch(),
 * @param {Object} action is action's object that's passed in dipsatch().
 * @param {Card} restoredCard is the stone card object that will be restored.
 */ 
function handlePlayRestoreCard(state, action, restoredCard) {
    let newState = deepCopyState(state);
    if (action.isPlayedSameCard) {
        newState = handleSameCard(newState, action);
    }
    // remove the "restore stone" with simulating playing the restored stone.
    let restoringStoneCard = new Card(Card.RESTORE_STONE, 0);
    newState.playersData[newState.turnIndex].waste(restoringStoneCard);
    newState.playersData[newState.turnIndex].player.cards.
        push(restoredCard);
    let hasFinished = newState.playersData[newState.turnIndex].play(restoredCard, null);
    // making the restoring stone card as the las played card.
    newState.playersData[newState.turnIndex].lastPlayedCard = restoringStoneCard;
    if (hasFinished) {
        state.isGameFinished = true;
    }
    return newState;
} 

/**
 * It handles changing the state for the action switch turn.
 * @param {Object} state It's the state object passed from dispatch(),
 * @param {Object} action is action's object that's passed in dipsatch().
 * @return {Object} that's the next state after deep copying the old one
 */ 
function handleSwitchTurn(state, action) {
    let newState = deepCopyState(state);
    // check if the player is allowed to play/waste multiple cards
    if (newState.turnCount[newState.turnIndex] === 1 || newState.turnIndex === -1) {
        // check if the next player can play(no one targeted the player with prevent play)
        let nextTurnIndex = (newState.turnIndex + 1 >= newState.playersData.length) ? 0 :
        newState.turnIndex + 1; 
        while (newState.turnCount[nextTurnIndex] <= 0) {
            newState.turnCount[nextTurnIndex] = newState.turnCount[nextTurnIndex] + 1;
            nextTurnIndex = (nextTurnIndex + 1 >= newState.playersData.length) ? 0 
                : nextTurnIndex + 1;
        }
        newState.turnIndex = nextTurnIndex;
        newState.playersData[newState.turnIndex].hasPlayTwice = false;
    } else {
        newState.turnCount[newState.turnIndex] = newState.turnCount[newState.turnIndex] - 1;
    }
    return newState;
}

export const gameManager = (state = intialState, action) => {
    let newState;
    switch(action.type) {
        case actions.PLAY_ACTION:
            newState = deepCopyState(state);
            if (action.isPlayedSameCard) {
                newState = handleSameCard(newState, action);
            }
            if (action.isPlayedCardPick) { 
                // it replaces the "pick card" with the stolen card inside hand cards array.
                // also it handles removing the picked card from the opponent.
                newState = handlePickCard(newState, action);
                // updating action if needed
                if (action.playedCard.cardName === Card.PICK_CARD) {
                    action.playedCard = action.stolenCard;
                    action.stolenCard = null;
                    action.opponentIndex = -1;
                }
            }
            if (action.opponentIndex === -1) { // It does not target opponents' cards
                newState = handleNonTargetingCards(newState, action);
            } else { // It does target opponent's cards
                switch(action.playedCard.cardName) {
                    case Card.HAMMER:
                        newState = handleHammerAttack(newState, action, false);
                    break;
                    case Card.PREVENT_NEXT_TURN:
                        newState = handlePreventTurn(newState, action);
                    break;
                    case Card.SHIELD_DETROYER:
                        newState = handleShieldDestroyer(newState, action);
                    break;
                    case Card.STONE_STEALLING:
                    case Card.MIRROR_SHIELD_STEALLING:
                    case Card.NORMAL_SHIELD_STEALLING:
                        newState = handleSteallingCard(newState, action);
                    break;
                }
            }
            if (action.isPlayedCardPick) {
                newState.playersData[state.turnIndex].lastPlayedCard = new Card(Card.PICK_CARD, 0);
            }
            return newState;
        case actions.PLAY_RESTORE_ACTION:
            return handlePlayRestoreCard(state, action, action.restoredStone);
        break;
        case actions.WASTE_ACTION:
            newState = deepCopyState(state);
            if (action.isPlayedSameCard) {
                newState = handleSameCard(state, action);
            }
            if (action.isPlayedCardPick) { 
                // it replaces the "pick card" with the stolen card inside hand cards array.
                // also it handles removing the picked card from the opponent.
                return handleWastingPickedCard(newState, action);
            }
            newState.playersData[newState.turnIndex].waste(action.card);
            return newState;
        case actions.SETUP_OFFLINE_GAME:
            newState = {
                playersData: [],
                cardsDeck: new CardsDeck("offline", null),
                turnIndex: -1, // -1 so that when incremented by 1 it's 0(bottom player)
                turnCount: [], 
                isGameFinished: false, 
                winnerName: "", 
                isCardDeckFinished: false
            };
            newState.playersData.push(new CoordinatorPlayer("You", []));
            newState.turnCount.push(1);
            for (let i = 1; i < action.num; i++) {
                newState.playersData.push(new CoordinatorPlayer("AI " + i, []));
                newState.turnCount.push(1);
            }
            return newState;
        case actions.SETUP_ONLINE_GAME:
            newState = {
                playersData: [],
                cardsDeck: new CardsDeck("online", action.cardsNames),
                turnIndex: action.currTurn -1, // -1 b/c it will be incremented by 1 at the start of the game
                turnCount: [], 
                isGameFinished: false, 
                winnerName: "", 
                isCardDeckFinished: false
            };
            for (let player of action.playersInfo) {
                newState.playersData.push(new CoordinatorPlayer(player.name, []));
                newState.turnCount.push(1);
            }
            return newState;
        case actions.SWITCH_TURN:
            return handleSwitchTurn(state, action);
        case actions.DRAW_CARDS:
            newState = deepCopyState(state);
            for (let i = 0 ; i < action.num; i++) {
                newState.playersData[newState.turnIndex].player.cards.push(
                    newState.cardsDeck.cards.pop());
                if (newState.cardsDeck.cards.length <= 4) {
                    newState.isCardDeckFinished = true;
                }
            }
            return newState;
        case actions.ADD_CARDS_TO_DECK:
            newState = deepCopyState(state);
            if (action.isOfflineMode) {
                newState.cardsDeck = new CardsDeck("offline", null);
            } else {
                newState.cardsDeck = new CardsDeck("online", action.retrievedCard);
            }
            newState.isCardDeckFinished = false;
            return newState;
        case actions.FINISH_GAME:
        let returnedState = intialState;
        return returnedState;
        default:
            return state;
    }
}